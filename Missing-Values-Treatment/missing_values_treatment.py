# -*- coding: utf-8 -*-
"""Missing_Values_Treatment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qMZg8uckhQ9dtWAwocPxYw84BAa3fsJf
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

pd.set_option('display.float_format', lambda x: '%.2f' %x)

df = pd.read_csv('brittleness-index.csv')

df

df.shape

df.info()

df.describe()

df.columns

df.isnull().sum()

(df.isnull().sum() * 100 / df.index.size).round(2).sort_values(ascending=False)

df.isnull().sum(axis=1).sum()

df[df.isnull().any(axis=1)].index

tk104_null = df[df['TK104'].isnull()].index
tk104_null

tk105_null = df[df['TK105'].isnull()].index
tk105_null

sns.heatmap(df.isnull(), cmap='coolwarm', cbar=False)
plt.show()

"""### Method 1: Dropping Missing Values"""

df_drop = df.copy()
df_drop.dropna(axis=0, inplace=True)

df_drop.reset_index(inplace=True, drop=True)
df_drop

"""### Method 2: Fill with a Specific Value"""

df_fill = df.copy()
df_fill.fillna(df_fill.median(), inplace=True)

df_fill

df_fill.median()

"""### Method 3: Backward of Forward fill"""

df

df_fb = df.copy()
df_fb.ffill(inplace=True)
df_fb

"""### Method 4: Sklearn Library Module Imputer"""

from sklearn.impute import SimpleImputer

df_si = df.copy()

imputer = SimpleImputer(strategy='mean')
x = imputer.fit_transform(df_si)

df_si = pd.DataFrame(x, columns=df_si.columns)
df_si

df_si = df.copy()

imputer = SimpleImputer(strategy='median')
x = imputer.fit_transform(df_si)

df_si = pd.DataFrame(x, columns=df_si.columns)
df_si

df_si = df.copy()

imputer = SimpleImputer(strategy='constant', fill_value=0)
x = imputer.fit_transform(df_si)

df_si = pd.DataFrame(x, columns=df_si.columns)
df_si

from sklearn.impute import KNNImputer

df_knn = df.copy()

imputer = KNNImputer(n_neighbors=3)
x = imputer.fit_transform(df_knn)

df_knn = pd.DataFrame(x, columns=df_knn.columns)
df_knn

df_outlier = df.copy()
df_outlier

df_outlier.columns

plt.figure(figsize=(10, 4))

for i in range(len(df_outlier.columns)):
    plt.subplot(1, 3, i + 1)
    sns.boxplot(y = df_outlier.columns[i], data=df_outlier)
    plt.title(df_outlier.columns[i])
plt.show()

from sklearn.preprocessing import RobustScaler

scaler = RobustScaler()
x = scaler.fit_transform(df_outlier)

df_outlier = pd.DataFrame(x, columns=df_outlier.columns)

knn_imputer = KNNImputer(n_neighbors=3)
x = knn_imputer.fit_transform(df_outlier)

df_outlier = pd.DataFrame(x, columns=df_outlier.columns)
df_outlier

from sklearn.experimental import enable_iterative_imputer
from sklearn.impute import IterativeImputer
from sklearn.preprocessing import StandardScaler

df_iter = df.copy()

for column in df_iter.columns:
  Q1 = df_iter[column].quantile(.25)
  Q3 = df_iter[column].quantile(.75)
  IQR = Q3 - Q1

  lower_bound = Q1 - 1.5 * 3
  upper_bound = Q3 + 1.5 * 3

  df_iter[column] = np.where(df_iter[column] < lower_bound, lower_bound, df_iter[column])
  df_iter[column] = np.where(df_iter[column] > upper_bound, upper_bound, df_iter[column])

scaler = StandardScaler()
data_to_impute = scaler.fit_transform(df_iter)

imputer = IterativeImputer(max_iter=10, random_state=0)
data_imputed = imputer.fit_transform(data_to_impute)

df_iter = pd.DataFrame(scaler.inverse_transform(data_imputed), columns=df_iter.columns)
df_iter

